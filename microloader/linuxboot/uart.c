#include "u3phy.h"
#include <linuxboot/types.h>
#include <lk/api.h>

#define ACR4 0x11290810
#define ACR6 0x11290818
#define DTM0 0x11290868
#define DTM1 0x1129086C

#define INFRASYS_BASE 0x10001000

uint32_t mmio_read32(uint32_t addr)
{
    __asm__ __volatile__("dsb" ::
                             : "memory");
    uint32_t x = *((volatile uint32_t *)addr);
    return x;
}

void mmio_write32(uint32_t addr, uint32_t value)
{
    *((volatile uint32_t *)addr) = value;
    __asm__ __volatile__("dsb\nisb" ::
                             : "memory");
}

void enable_uart(void)
{
    // switch usb to uart
    mmio_write32(ACR6, mmio_read32(ACR6) & ~RG_USB20_BC11_SW_EN);
    mmio_write32(DTM0, mmio_read32(DTM0) | FORCE_UART_EN | FORCE_UART_TX_OE | FORCE_UART_BIAS_EN | (1 << RG_UART_MODE_OFST));
    mmio_write32(DTM1, mmio_read32(DTM1) | RG_UART_EN | RG_UART_TX_OE | RG_UART_BIAS_EN);
    mmio_write32(ACR4, mmio_read32(ACR4) | RG_USB20_DM_100K_EN);
    mmio_write32(DTM0, mmio_read32(DTM0) | RG_SUSPENDM);
    mmio_write32(DTM0, mmio_read32(DTM0) | FORCE_SUSPENDM);

    // GPIO Selection
    // 0x10005000 = gpio base
    mmio_write32(0x10005000 + 0x6E0, mmio_read32(0x10005000 + 0x6E0) | 0x80000);
    // that's all thats required on hw side
    // it assumes that usb clock is on
    // code for MT6755/MT6750
    // probably could be ported to other platforms with very little effort
    // see mu3phy driver for your SOC in linux source code
    // -------------------------------------------------

    // enable printk to uart
    *((volatile uint8_t *)(0x46074228 + 20)) = '0';

    // patch LK to make it write output to uart
    *((volatile uint16_t *)0x46002E70) = 0x4b03;
    *((volatile uint16_t *)0x46002E72) = 0x695a;
    *((volatile uint16_t *)0x46002E74) = 0xf012;
    *((volatile uint16_t *)0x46002E76) = 0x0f20;
    *((volatile uint16_t *)0x46002E78) = 0xd0fb;
    *((volatile uint16_t *)0x46002E7A) = 0x6018;
    *((volatile uint16_t *)0x46002E7C) = 0x4770;
    // output to apuart0
    *((volatile uint32_t *)0x46002E80) = 0x11002000;

    __asm__ __volatile__("dsb\nisb");
    // move data from DCACHE to RAM
    arch_clean_invalidate_cache_range(0x46002E70, 0x46002E80 - 0x46002E70 + 8);
    // invalidate ICACHE
    // TODO: verify if is that correct
    __asm__ __volatile__("mcr p15, 0, r12, c7, c5, 0" ::
                             : "r12");
}

/*bool is_ssusb_top_on(bool print)
{
    uint32_t status = *((volatile uint32_t *)(INFRASYS_BASE + 0xac));
    video_printf("status = 0x%x\n", status & 2);

    bool is_on = (status & 2) == 0;
    if (print)
        video_printf("SSUSB_TOP status: %s\n", is_on ? "ON" : "OFF");
    return is_on;
}

void ssusb_top_off()
{
    *((volatile uint32_t *)(INFRASYS_BASE + 0xa4)) = 2;
}

void ssusb_top_on()
{
    *((volatile uint32_t *)(INFRASYS_BASE + 0xa8)) = 2;
}*/